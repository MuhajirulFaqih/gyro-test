<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>SOCAi Tilt Overlay Demo</title>

<style>
body{
  margin:0;
  background:#0f0f14;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  height:100vh;
  font-family:sans-serif;
  color:white;
}

.container{
  position:relative;
  width:320px;
  height:320px;
}

.target{
  position:absolute;
  width:140px;
  height:140px;
  border:3px solid white;
  border-radius:50%;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
}

.dynamic{
  position:absolute;
  width:140px;
  height:140px;
  border:3px solid #FF4D4D;
  border-radius:50%;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
}

button{
  margin-top:30px;
  padding:12px 20px;
}
</style>
</head>
<body>

<h3>SOCAi Gyro Alignment Demo</h3>

<div class="container">
  <div class="target"></div>
  <div class="dynamic" id="dynamicCircle"></div>
</div>

<div id="debug">Waiting...</div>
<button id="startBtn">Start</button>

<script>

const circle = document.getElementById("dynamicCircle");
const debug = document.getElementById("debug");
const btn = document.getElementById("startBtn");

let running = false;

// Raw sensor values
let targetX = 0;
let targetY = 0;
let currentX = 0;
let currentY = 0;

// Spring smoothing
const spring = 0.08;
const friction = 0.85;

let velocityX = 0;
let velocityY = 0;

function animate(){

  velocityX += (targetX - currentX) * spring;
  velocityY += (targetY - currentY) * spring;

  velocityX *= friction;
  velocityY *= friction;

  currentX += velocityX;
  currentY += velocityY;

  const distance = Math.sqrt(currentX*currentX + currentY*currentY);

  // Magnetic snap
  if(distance < 8){
    currentX *= 0.6;
    currentY *= 0.6;
  }

  // Depth effect (scale based on forward/back tilt)
  const depthScale = 1 + (Math.abs(currentY) / 300);

  circle.style.transform =
    `translate(calc(-50% + ${currentX}px), calc(-50% + ${currentY}px))
     scale(${depthScale})`;

  circle.style.borderColor =
    distance < 10 ? "#2BE38C" : "#FF4D4D";

  requestAnimationFrame(animate);
}

function handleOrientation(event){

  const gamma = event.gamma || 0; // left-right
  const beta  = event.beta  || 0; // forward-back

  const sensitivity = 2.5;

  targetX = gamma * sensitivity;
  targetY = beta * sensitivity;

  debug.innerText =
    "gamma: " + gamma.toFixed(1) +
    " | beta: " + beta.toFixed(1);
}

function start(){

  if(running){
    window.removeEventListener("deviceorientation", handleOrientation);
    btn.innerText = "Start";
    running = false;
    return;
  }

  if(typeof DeviceOrientationEvent !== "undefined" &&
     typeof DeviceOrientationEvent.requestPermission === "function"){

    DeviceOrientationEvent.requestPermission()
      .then(response=>{
        if(response === "granted"){
          window.addEventListener("deviceorientation", handleOrientation);
        }
      })
      .catch(console.error);

  }else{
    window.addEventListener("deviceorientation", handleOrientation);
  }

  btn.innerText = "Stop";
  running = true;
}

btn.addEventListener("click", start);

animate();

</script>

</body>
</html>
